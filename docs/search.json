[
  {
    "objectID": "rstac.html",
    "href": "rstac.html",
    "title": "Download data from a STAC API using R, rstac, and GDAL",
    "section": "",
    "text": "This tutorial walks through querying a STAC API using the rstac R package, and downloading data from the API using rstac or GDAL (via sf). This tutorial will assume that you’re already familiar with R and working with spatial data.\nAs all of the packages we’ll be using are available from CRAN, you can install them (if necessary) using install.packages():\n\ninstall.packages(\"sf\")\ninstall.packages(\"rstac\")\ninstall.packages(\"terra\")\n\nSTAC APIs are servers that provide access to a set of data which users can query and retrieve. You can find a partial list of STAC APIs at STAC Index, https://stacindex.org/. For this tutorial, we’ll be downloading data from Microsoft’s Planetary Computer, which currently provides more than 100 data sets for free via a central STAC API.\nTo start downloading data, we’ll first need to let rstac know what STAC API we want to query and download from. To do so, we’ll pass the URL of the Planetary Computer STAC API to the rstac::stac() function:\n\nstac_source &lt;- rstac::stac(\n  \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n)\nstac_source\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nAs you can see, the output of stac() is an RSTACQuery object, which contains information about an HTTP query that we might want to run in the future. Under the hood, these objects are normal lists containing information about the query:\n\nstr(stac_source)\n\nList of 6\n $ version : NULL\n $ base_url: chr \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n $ endpoint: NULL\n $ params  : list()\n $ verb    : chr \"GET\"\n $ encode  : NULL\n - attr(*, \"class\")= chr [1:2] \"stac\" \"RSTACQuery\"\n\n\nBut most of the time, you won’t need to worry about this internal representation; rstac provides many helper functions to access the elements of this list if needed.\nIt’s worth highlighting that this object is a representation of a future HTTP query, not the results of a query we’ve already run! In order to actually run these queries, we need to use rstac::get_request() (or rstac::post_request(), depending on what HTTP verb your STAC API is expecting). If we use get_request() to query the Planetary Computer STAC API, we get a brief description of what this API provides:\n\nrstac::get_request(stac_source)\n\n###STACCatalog\n- id: microsoft-pc\n- description: \nSearchable spatiotemporal metadata describing Earth science datasets hosted by the Microsoft Planetary Computer\n- field(s): type, id, title, description, stac_version, conformsTo, links\n\n\nBecause the RSTACQuery object is a representation of a future query, we can use other functions in rstac to change our query parameters and fields before we actually make a request. For instance, we can use rstac::collections() to update our request to query the /collections endpoint of the Planetary Computer API, which lists all the available collections (which, to quote the STAC Collection specification, “describe a group of Items that share properties and metadata”):\n\ncollections_query &lt;- stac_source |&gt;\n  rstac::collections()\n\ncollections_query\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nWhile it might not look like much has changed, under the hood our collections_query object has a new collections class to indicate that we’re querying the collections endpoint, not the top-level STAC endpoint:\n\nclass(stac_source)\n\n[1] \"stac\"       \"RSTACQuery\"\n\nclass(collections_query)\n\n[1] \"collections\" \"RSTACQuery\" \n\n\nAnd as a result, when we use get_request() to turn this query specification into a query result, we get a list of the collections available from this API:\n\navailable_collections &lt;- rstac::get_request(collections_query)\navailable_collections\n\n###STACCollectionList\n- collections (122 item(s)):\n  - daymet-annual-pr\n  - daymet-daily-hi\n  - 3dep-seamless\n  - 3dep-lidar-dsm\n  - fia\n  - sentinel-1-rtc\n  - gridmet\n  - daymet-annual-na\n  - daymet-monthly-na\n  - daymet-annual-hi\n  - ... with 112 more collection(s).\n- field(s): collections, links\n\n\nThese collections are a subset of the data sets available in the Planetary Computer data catalog; the Planetary Computer is organized so that each collection corresponds to a distinct data set in the catalog.\nFor our purposes today, we’re going to be querying the USGS Land Change Monitoring, Assessment, and Projection (LCMAP) collection, which provides (among other things) annual land cover classifications for the continental United States. We can query what items are available for this collection using the rstac::stac_search() function. We’ll limit our search to 2021 using the datetime argument, and only search within the LCMAP collection by using the collection’s ID of usgs-lcmap-conus-v13:\n\nrstac::stac_search(\n  q = stac_source,\n  collections = \"usgs-lcmap-conus-v13\",\n  datetime = \"2021-01-01/2021-12-31\"\n) |&gt; \n  rstac::get_request()\n\n###STACItemCollection\n- features (250 item(s)):\n  - LCMAP_CU_032003_2021_V13_CCDC\n  - LCMAP_CU_031006_2021_V13_CCDC\n  - LCMAP_CU_031004_2021_V13_CCDC\n  - LCMAP_CU_031003_2021_V13_CCDC\n  - LCMAP_CU_031002_2021_V13_CCDC\n  - LCMAP_CU_030007_2021_V13_CCDC\n  - LCMAP_CU_030006_2021_V13_CCDC\n  - LCMAP_CU_030005_2021_V13_CCDC\n  - LCMAP_CU_030004_2021_V13_CCDC\n  - LCMAP_CU_030003_2021_V13_CCDC\n  - ... with 240 more feature(s).\n- assets: \nbrowse, dates, lcachg, lcachg_metadata, lcpconf, lcpconf_metadata, lcpri, lcpri_metadata, lcsconf, lcsconf_metadata, lcsec, lcsec_metadata, rendered_preview, sclast, sclast_metadata, scmag, scmag_metadata, scmqa, scmqa_metadata, scstab, scstab_metadata, sctime, sctime_metadata, tilejson\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nWe can see that there are 250 items inside this catalog for 2021. Collectively, these items contain all LCMAP data for the continental United States for 2021, with each item containing a number of assets covering a relatively small chunk of the nation. These assets are “object[s] that [contain] a URI to data associated with the Item that can be downloaded or streamed”, to quote the spec; here, assets are things like “primary land cover classification” or “a metadata object”.\nTo keep things simple, we’ll start off downloading data for a relatively small region, namely North Carolina’s Ashe County. We’ll use data included in the sf package to get the county’s geometry:\n\nashe &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))[1, ]\n\nsf::st_geometry(ashe) |&gt; plot()\n\n\n\n\n\n\n\n\n\n\nTo filter our query down to just tiles intersecting this region, we’ll need to provide the bounding box of the county in WGS84 as a query parameter. We can use sf::st_transform() to reproject the county and sf::st_bbox() to find our bounding box:\n\nashe_bbox &lt;- ashe |&gt;\n  sf::st_transform(4326) |&gt;\n  sf::st_bbox()\n\nashe_bbox\n\n     xmin      ymin      xmax      ymax \n-81.74091  36.23448 -81.23970  36.58977 \n\n\nWe can then pass this bounding box directly to the bbox argument of stac_search to filter our results down further:\n\nstac_query &lt;- rstac::stac_search(\n  q = stac_source,\n  collections = \"usgs-lcmap-conus-v13\",\n  bbox = ashe_bbox,\n  datetime = \"2021-01-01/2021-12-31\"\n)\n\nexecuted_stac_query &lt;- rstac::get_request(stac_query)\n\nexecuted_stac_query\n\n###STACItemCollection\n- features (1 item(s)):\n  - LCMAP_CU_025011_2021_V13_CCDC\n- assets: \nbrowse, dates, lcachg, lcachg_metadata, lcpconf, lcpconf_metadata, lcpri, lcpri_metadata, lcsconf, lcsconf_metadata, lcsec, lcsec_metadata, rendered_preview, sclast, sclast_metadata, scmag, scmag_metadata, scmqa, scmqa_metadata, scstab, scstab_metadata, sctime, sctime_metadata, tilejson\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs luck would have it, Ashe County is entirely contained in a single LCMAP tile.\nThere are a few different ways to download the assets associated with this item. First, we could use the rstac::assets_download() function. Before we can download assets, however, we’re going to need to authenticate ourselves with Planetary Computer. Note that this doesn’t require an account or registration, but rather is a way for Microsoft to uniquely identify your Planetary Computer session and impose rate limits if needed.\nThis authentication process is built-in to rstac, using the items_sign() and sign_planetary_computer() functions:\n\nsigned_stac_query &lt;- rstac::items_sign(\n  executed_stac_query,\n  rstac::sign_planetary_computer()\n)\n\nsigned_stac_query\n\n###STACItemCollection\n- features (1 item(s)):\n  - LCMAP_CU_025011_2021_V13_CCDC\n- assets: \nbrowse, dates, lcachg, lcachg_metadata, lcpconf, lcpconf_metadata, lcpri, lcpri_metadata, lcsconf, lcsconf_metadata, lcsec, lcsec_metadata, rendered_preview, sclast, sclast_metadata, scmag, scmag_metadata, scmqa, scmqa_metadata, scstab, scstab_metadata, sctime, sctime_metadata, tilejson\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nWe didn’t need to log in or register anywhere, but now have authenticated our requests and will be able to download assets from this STAC API.\nWe’ll then use this signed query object with assets_download() to actually retrieve our assets. We’ll provide the name of what assets we want to download – let’s start off by downloading lcpri, which contains the primary land cover classifications for this area:\n\nrstac::assets_download(signed_stac_query, \"lcpri\", output_dir = tempdir())\n\nWe’re downloading these into a temporary directory (using tempdir()) so that these example files will be cleaned up after we finish running this tutorial. In practice, you’ll likely want to set output_dir somewhere else, where the data will persist for as long as you need.\nThe assets_download() function will save your data in a sub-directory of output_dir that corresponds to the URL that the asset is being downloaded from. In this case, that winds up being quite a long folder path – but once we type the folder path out, we can load our downloaded raster into R and use it with terra and other raster packages as normal:\n\noutput_file &lt;- file.path(\n  tempdir(),\n  \"lcmap\",\n  \"CU\",\n  \"V13\",\n  \"025011\",\n  \"2021\",\n  \"LCMAP_CU_025011_2021_20220721_V13_CCDC\",\n  \"LCMAP_CU_025011_2021_20220629_V13_LCPRI.tif\"\n) |&gt;\n  terra::rast()\n\nterra::plot(output_file)\n\n\n\n\n\n\n\n\n\n\nThe assets_download() function is an easy and straightforward way to download assets associated with a STAC Item, and by passing multiple asset names (or leaving the asset_names argument NULL) we could use this function to download more than one asset at a time. This function can also handle any format an asset is stored in, making it a flexible way to download rasters, metadata, vectors, or whatever other data is provided by a STAC API.\nThe main downside of this approach, however, is that we can’t use it to download only specific parts of an asset, which means we can wind up downloading much more data than we need. For instance, look at how far our land cover raster extends beyond Ashe County’s borders:\n\nterra::plot(output_file)\nashe |&gt;\n  sf::st_transform(sf::st_crs(output_file)) |&gt;\n  sf::st_geometry() |&gt;\n  plot(add = TRUE, lwd = 3)\n\n\n\n\n\n\n\n\n\n\nAn alternative approach for downloading raster assets is to use GDAL’s virtual file system interface to download rasters. If the STAC server stores the asset in a cloud-friendly format, such as COG, then GDAL is able to download only the necessary pieces of the raster, potentially speeding up download times and reducing bandwidth usage.\nTo download assets using GDAL, we need to extract the URL for our assets from our unsigned STAC query results. We can get the URL for the lcpri asset using rstac::assets_url():\n\nlcpri_url &lt;- rstac::assets_url(executed_stac_query, \"lcpri\")\nlcpri_url\n\n[1] \"https://landcoverdata.blob.core.windows.net/lcmap/CU/V13/025011/2021/LCMAP_CU_025011_2021_20220721_V13_CCDC/LCMAP_CU_025011_2021_20220629_V13_LCPRI.tif\"\n\n\nIn order for this URL to work with GDAL’s virtual filesystem interface, we’ll need to append a few things in front of the URL. Namely, we’ll need to add:\n\n/vsicurl, to specify that we want to use the http-based virtual filesytem interface,\npc_url_signing=yes, to use GDAL’s built-in method for signing requests to Microsoft’s Planetary Computer,\nand pc_collection=usgs-lcmap-conus-v13, to let GDAL know what collection we need authentication for.\n\nAll of these configuration parameters are documented in the official GDAL documentation.\nWe can write a small function that will paste these parameters on to any URL we want:\n\nmake_vsicurl_url &lt;- function(base_url) {\n  paste0(\n    \"/vsicurl\", \n    \"?pc_url_signing=yes\",\n    \"&pc_collection=usgs-lcmap-conus-v13\",\n    \"&url=\",\n    base_url\n  )\n}\n\nWe might have chosen to make this function a bit more flexible by adding a collection argument, so that we can sign requests for data in any collection we’d want. For our purposes here, however, this simpler function should suffice.\nWe can then use this function to modify our LCMAP URL:\n\nlcpri_url &lt;- make_vsicurl_url(lcpri_url)\n\nNext, we’ll download the lcpri asset from this URL using sf::gdal_utils(), which provides access to GDAL’s C++ utilities. We’ll use the included interface to gdalwarp to both download and reproject our data, using the t_srs and te arguments to gdalwarp to control the spatial reference system and the extent of our downloaded raster:\n\nout_file &lt;- tempfile(fileext = \".tif\")\nsf::gdal_utils(\n  \"warp\",\n  source = lcpri_url,\n  destination = out_file,\n  options = c(\n    \"-t_srs\", sf::st_crs(ashe)$wkt,\n    \"-te\", sf::st_bbox(ashe)\n  )\n)\n\nThis download runs a good bit faster than using assets_download(), and results in a smaller raster covering only our area of interest, reprojected into the same CRS as our original data:\n\nterra::rast(out_file) |&gt;\n  terra::plot()\nashe |&gt;\n  sf::st_geometry() |&gt;\n  plot(lwd = 3, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nAt this point, we’ve walked through how to use rstac to query a STAC API, and how to use either rstac or GDAL to download assets found in these queries. It’s worth highlighting that so far we’ve only needed to write about 40 lines of code; here’s everything we’ve walked through so far, presented as a single script instead of in a bunch of chunks:\n\nashe &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))[1, ]\nashe_bbox &lt;- ashe |&gt;\n  sf::st_transform(4326) |&gt;\n  sf::st_bbox()\n\nstac_query &lt;- rstac::stac(\n  \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n) |&gt;\n  rstac::stac_search(\n    collections = \"usgs-lcmap-conus-v13\",\n    bbox = ashe_bbox,\n    datetime = \"2021-01-01/2021-12-31\"\n  ) |&gt;\n  rstac::get_request()\n\nmake_vsicurl_url &lt;- function(base_url) {\n  paste0(\n    \"/vsicurl\", \n    \"?pc_url_signing=yes\",\n    \"&pc_collection=usgs-lcmap-conus-v13\",\n    \"&url=\",\n    base_url\n  )\n}\n\nlcpri_url &lt;- make_vsicurl_url(rstac::assets_url(stac_query, \"lcpri\"))\n\nout_file &lt;- tempfile(fileext = \".tif\")\nsf::gdal_utils(\n  \"warp\",\n  source = lcpri_url,\n  destination = out_file,\n  options = c(\n    \"-t_srs\", sf::st_crs(ashe)$wkt,\n    \"-te\", sf::st_bbox(ashe)\n  )\n)\n\nterra::rast(out_file) |&gt;\n  terra::plot()\nashe |&gt; \n  sf::st_geometry() |&gt; \n  plot(lwd = 3, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nWhat if we wanted to download more than one raster asset? We could choose to pass multiple asset names to assets_download(). For instance, if we wanted to also download the secondary land cover classification for this area (called lcsec), we could write:\n\nrstac::assets_download(\n  signed_stac_query, \n  c(\"lcpri\", \"lcsec\"), \n  output_dir = tempdir(),\n  overwrite = TRUE\n)\n\nNote that we needed to set overwrite = TRUE, in order to re-download the lcpri asset that we had already retrieved.\nThese rasters are now somewhere in our output_dir directory. We can find their file paths using list.files() in order to load and visualize them:\n\nlist.files(\n  file.path(tempdir(), \"lcmap\"),\n  recursive = TRUE,\n  full.names = TRUE\n) |&gt; \n  terra::rast() |&gt;\n  terra::plot()\n\n\n\n\n\n\n\n\n\n\nIf we wanted to download multiple assets using sf and GDAL, we’d need to run our gdal_utils() call for each asset we wanted to download. For instance, to download both lcpri and lcsec, we could run:\n\nvapply(\n  make_vsicurl_url(rstac::assets_url(stac_query, c(\"lcpri\", \"lcsec\"))),\n  function(asset_url) {\n    out_file &lt;- tempfile(fileext = \".tif\")\n    sf::gdal_utils(\n      \"warp\",\n      source = asset_url,\n      destination = out_file,\n      options = c(\n        \"-t_srs\", sf::st_crs(ashe)$wkt,\n        \"-te\", sf::st_bbox(ashe)\n      )\n    )\n    out_file\n  },\n  character(1)\n) |&gt; \n  terra::rast() |&gt; \n  terra::plot()\n\n\n\n\n\n\n\n\n\n\nWhat if we wanted to download the same asset from more than one item? For instance, what if we wanted to download lcpri for all of North Carolina?\nWe could construct our STAC query in almost exactly the same way as before, except using the entire nc data frame instead of just its first row:\n\nnc &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nnc_bbox &lt;- nc |&gt;\n  sf::st_transform(4326) |&gt;\n  sf::st_bbox()\n\nstac_query &lt;- rstac::stac(\n  \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n) |&gt;\n  rstac::stac_search(\n    collections = \"usgs-lcmap-conus-v13\",\n    bbox = nc_bbox,\n    datetime = \"2021-01-01/2021-12-31\"\n  ) |&gt;\n  rstac::get_request()\n  \nsigned_query &lt;- stac_query |&gt;   \n  rstac::items_sign(\n    rstac::sign_planetary_computer()\n  )\n\nsigned_query\n\n###STACItemCollection\n- features (20 item(s)):\n  - LCMAP_CU_029012_2021_V13_CCDC\n  - LCMAP_CU_029011_2021_V13_CCDC\n  - LCMAP_CU_028013_2021_V13_CCDC\n  - LCMAP_CU_028012_2021_V13_CCDC\n  - LCMAP_CU_028011_2021_V13_CCDC\n  - LCMAP_CU_028010_2021_V13_CCDC\n  - LCMAP_CU_027013_2021_V13_CCDC\n  - LCMAP_CU_027012_2021_V13_CCDC\n  - LCMAP_CU_027011_2021_V13_CCDC\n  - LCMAP_CU_027010_2021_V13_CCDC\n  - ... with 10 more feature(s).\n- assets: \nbrowse, dates, lcachg, lcachg_metadata, lcpconf, lcpconf_metadata, lcpri, lcpri_metadata, lcsconf, lcsconf_metadata, lcsec, lcsec_metadata, rendered_preview, sclast, sclast_metadata, scmag, scmag_metadata, scmqa, scmqa_metadata, scstab, scstab_metadata, sctime, sctime_metadata, tilejson\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs you can see, we now have 20 items to download, rather than just 1!\nWe barely need to change our code at all to download all 20 lcpri assets from these items using assets_download(). We’re simply going to set progress = FALSE, in order to keep the output from this function clean. Other than that, we don’t need to change a thing:\n\nrstac::assets_download(\n  signed_query, \n  \"lcpri\",\n  output_dir = tempdir(),\n  overwrite = TRUE,\n  progress = FALSE\n)\n\nThese files are each saved into their own folder inside of output_dir. We can use list.files() to get the paths to each of them, and then terra::sprc() and terra::mosaic() to combine them into a single raster:\n\nlcpri &lt;- list.files(\n  file.path(tempdir(), \"lcmap\"),\n  pattern = \"LCPRI.tif\",\n  recursive = TRUE,\n  full.names = TRUE\n) |&gt; \n  lapply(terra::rast) |&gt; \n  terra::sprc() |&gt; \n  terra::mosaic()\n\nterra::plot(lcpri)\nnc |&gt; \n  sf::st_transform(sf::st_crs(lcpri)) |&gt; \n  sf::st_geometry() |&gt;\n  plot(lwd = 3, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nNote that we’ve lost our color palette due to mosaic(), but this is the same data as we’ve been working with throughout the entire tutorial.\nOr alternatively, we can use our gdal_utils() call – without any edits – to download and merge these files together. Remember that we’re using our unsigned query results here!\n\nout_file &lt;- tempfile(fileext = \".tif\")\nsf::gdal_utils(\n  \"warp\",\n  source = make_vsicurl_url(rstac::assets_url(stac_query, \"lcpri\")),\n  destination = out_file,\n  options = c(\n    \"-t_srs\", sf::st_crs(nc)$wkt,\n    \"-te\", sf::st_bbox(nc)\n  )\n)\n\nterra::rast(out_file) |&gt;\n  terra::plot()\nnc |&gt; \n  sf::st_geometry() |&gt; \n  plot(lwd = 3, add = TRUE)\n\n\n\n\n\n\n\n\n\n\nNote that gdalwarp does not interpolate between overlapping pixels, and instead simply uses the value from whichever pixel it processed last. That’s fine here, where our tiles shouldn’t overlap (and pixel values should be identical if they do), but means you shouldn’t use gdalwarp to combine images from multiple time periods into a single composite.\nIt’s worth highlighting that these are just two methods among many for downloading this data – you may also find using packages such as terra or gdalcubes useful for getting data from STAC APIs!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAC Sprint Tutorials",
    "section": "",
    "text": "During STAC Sprint #8 (9/26 - 9/28 2023) I had the opportunity to work on a handful of tutorials geared towards helping non-Python users query and download data from STAC APIs. This website collects the drafts as they existed during that week."
  },
  {
    "objectID": "r_cql.html",
    "href": "r_cql.html",
    "title": "Using rstac and CQL2 to query STAC APIs",
    "section": "",
    "text": "This tutorial builds upon the “Download data from a STAC API using R, rstac, and GDAL” tutorial tutorial, developing more complicated STAC queries using rstac to find, download, and process Landsat data using STAC metadata. That tutorial walks through building queries with rstac, using typical R functions to compose queries and download data. This tutorial walks through using rstac for more complex queries, based on CQL2 and the STAC API Filter Extension, and using the metadata provided by STAC APIs to filter through items and process assets.\nTo run this tutorial, you’ll need the rstac and sf packages. If necessary, you can install both packages via install.packages():\n\ninstall.packages(\"sf\")\ninstall.packages(\"rstac\")\n\nAs in the last tutorial, we’re going to start off by querying Microsoft’s Planetary Computer STAC API to get data for Ashe County, North Carolina. Let’s go ahead and load the geometry for the county:\n\nashe &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))[1, ]\n\nsf::st_geometry(ashe) |&gt; plot()\n\n\n\n\n\n\n\n\n\n\nLet’s try and get Landsat imagery for this area from January 2021. As we saw last time, we’re able to find all the STAC Items that match this description using rstac::stac_search(), providing our bounding box, time range, and desired data collection as regular function arguments. To get all the Landsat images for this spatiotemporal area of interest, we might write our query like this:\n\nashe_bbox &lt;- ashe |&gt;\n  sf::st_transform(4326) |&gt;\n  sf::st_bbox()\n\nstac_query &lt;- rstac::stac(\n  \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n) |&gt;\n  rstac::stac_search(\n    collections = \"landsat-c2-l2\",\n    bbox = ashe_bbox,\n    datetime = \"2021-01-01/2021-01-31\"\n  ) |&gt;\n  rstac::get_request()\n\nstac_query\n\n###STACItemCollection\n- features (12 item(s)):\n  - LE07_L2SP_017035_20210127_02_T1\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LE07_L2SP_018035_20210118_02_T1\n  - LE07_L2SP_018034_20210118_02_T2\n  - LE07_L2SP_017035_20210111_02_T2\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n  - LE07_L2SP_018035_20210102_02_T1\n  - LE07_L2SP_018034_20210102_02_T2\n- assets: \nang, atmos_opacity, atran, blue, cdist, cloud_qa, coastal, drad, emis, emsd, green, lwir, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs we can see, this returns 12 separate items. We can also see that those items seem to have different prefixes in their names; some start with LE07, while others start with LC08. We might be able to guess what this means (spoiler alert, LE07 corresponds to Landsat-7 imagery, while LC08 is Landsat-8), but we might also not know which of these items are actually relevant to our search.\nLuckily enough, STAC items include useful metadata about what their associated assets actually represent. This metadata gets converted by rstac into a list, which is then stored in the properties element of each item in our item collection. We can look at the names of these item properties to get a sense of what metadata is available for each of our items:\n\nlapply(stac_query$features, \\(x) names(x$properties)) |&gt; \n  unlist() |&gt; \n  unique()\n\n [1] \"gsd\"                         \"created\"                    \n [3] \"sci:doi\"                     \"datetime\"                   \n [5] \"platform\"                    \"proj:epsg\"                  \n [7] \"proj:shape\"                  \"description\"                \n [9] \"instruments\"                 \"eo:cloud_cover\"             \n[11] \"proj:transform\"              \"view:off_nadir\"             \n[13] \"landsat:wrs_row\"             \"landsat:scene_id\"           \n[15] \"landsat:wrs_path\"            \"landsat:wrs_type\"           \n[17] \"view:sun_azimuth\"            \"landsat:correction\"         \n[19] \"view:sun_elevation\"          \"landsat:cloud_cover_land\"   \n[21] \"landsat:collection_number\"   \"landsat:collection_category\"\n\n\nMany of these fields are defined by the STAC specification as common metadata, which defines fields that should mean the same thing across multiple data providers. For instance, the platform field should detail the “unique name of the specific platform to which the instrument is attached”, which means that we should be able to use it to confirm that the item naming conventions do in fact correspond to whether an image comes from Landsat-7 or Landsat-8:\n\nlapply(\n  stac_query$features, \n  \\(x) data.frame(id = x$id, platform = x$properties$platform)\n) |&gt; \n  do.call(what = rbind)\n\n                                id  platform\n1  LE07_L2SP_017035_20210127_02_T1 landsat-7\n2  LC08_L2SP_018035_20210126_02_T1 landsat-8\n3  LC08_L2SP_018034_20210126_02_T1 landsat-8\n4  LC08_L2SP_017035_20210119_02_T1 landsat-8\n5  LE07_L2SP_018035_20210118_02_T1 landsat-7\n6  LE07_L2SP_018034_20210118_02_T2 landsat-7\n7  LE07_L2SP_017035_20210111_02_T2 landsat-7\n8  LC08_L2SP_018035_20210110_02_T1 landsat-8\n9  LC08_L2SP_018034_20210110_02_T1 landsat-8\n10 LC08_L2SP_017035_20210103_02_T1 landsat-8\n11 LE07_L2SP_018035_20210102_02_T1 landsat-7\n12 LE07_L2SP_018034_20210102_02_T2 landsat-7\n\n\nThis metadata can be really useful to let us decide which items we want to download from, without needing to download the whole data object! To query using these fields, however, we’re going to need to build our queries in a different way. Namely, rather than using rstac::stac_search(), we’re going to have to write our queries in Common Query Language, or CQL2. CQL2 is a draft OGC standard setting out “a generic filter grammar […] used in query operations to identify the subset of resources, such as features, that should be included in a response”. STAC APIs which implement the filter extension can accept CQL2 queries, which can help you filter down the set of items returned by the API.\nCQL2 has a number of component pieces which define logical operators, spatial and temporal filters, and other filtering functiions. We’re going to focus primarily on how to use the most basic components to find items that intersect our spatiotemporal area of interest and have the properties we desire.\nLuckily, rstac supports writing CQL2 queries through the rstac::ext_filter() function, turning R’s logcal operators and objects into valid CQL2 queries. This function helps to translate R expressions into CQL2 that can be sent as a query to a STAC API. A handful of helper functions, prefixed with cql2_, also help translate R objects into valid CQL2 representations.\nFor instance, to turn our stac_search() query into an ext_filter() query, we’ll need to convert both our bounding box and datetime arguments. We can convert our bounding box into a representation that ext_filter() can use via rstac::cql2_bbox_as_geojson():\n\nashe_bbox_geojson &lt;- rstac::cql2_bbox_as_geojson(ashe_bbox)\nashe_bbox_geojson\n\n$type\n[1] \"Polygon\"\n\n$coordinates\n$coordinates[[1]]\n          [,1]     [,2]\n[1,] -81.74091 36.23444\n[2,] -81.23971 36.23444\n[3,] -81.23971 36.58973\n[4,] -81.74091 36.58973\n[5,] -81.74091 36.23444\n\n\nAnd we can convert our datetime into a valid interval using rstac::cql2_interval():\n\ntime_range &lt;- rstac::cql2_interval(\"2021-01-01\", \"2021-01-31\")\ntime_range\n\ninterval(\"2021-01-01\", \"2021-01-31\")\n\n\nWith these objects converted, we’re then able to build a query that uses CQL2 using rstac::ext_filter(). Rather than providing our filters as function arguments, like we did with stac_search(), we’re going to instead provide ext_filter() with a single query expression that combines all of the filters we care about. For instance, to request only items belonging to the Landsat collection, we’ll use == to filter to only items whose collection is landsat-c2-l2:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\"\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2'\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nIn addition to using logical operators, we’ll also use spatial and temporal operators to limit our results to only our area of interest. For instance, we’ll use the t_intersects CQL2 function and our time_range variable to limit our results to just January 2021. We’ll need to wrap our variable in {{}} to tell rstac to replace the variable name with its contents:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}})\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2' AND T_INTERSECTS(datetime,INTERVAL('2021-01-01','2021-01-31'))\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nNotice how we used && to combine these two filters, restricting our results to only items that satisfy both conditions. Also notice how the filter parameter in our rstac query has changed, including a call to T_INTERSECTS()!\nSimilarly, we’ll need to use the s_intersects() CQL2 function to restrict our results to our spatial area of interest using our ashe_bbox_geojson variable:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}})\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2' AND T_INTERSECTS(datetime,INTERVAL('2021-01-01','2021-01-31')) AND S_INTERSECTS(geometry,POLYGON((-81.740905671483 36.234442085901,-81.2397076336137 36.234442085901,-81.2397076336137 36.589729047258,-81.740905671483 36.589729047258,-81.740905671483 36.234442085901)))\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nThis query is equivalent to the one we constructed via stac_search(): we’re filtering our results based on collection and spatiotemporal range. To execute it against Planetary Computer, we’re going to need to use post_request(), rather than get_request(), to send this query as an HTTP POST rather than GET request:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}})\n  ) |&gt;\n  rstac::post_request()\n\n###STACItemCollection\n- features (12 item(s)):\n  - LE07_L2SP_017035_20210127_02_T1\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LE07_L2SP_018035_20210118_02_T1\n  - LE07_L2SP_018034_20210118_02_T2\n  - LE07_L2SP_017035_20210111_02_T2\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n  - LE07_L2SP_018035_20210102_02_T1\n  - LE07_L2SP_018034_20210102_02_T2\n- assets: \nang, atmos_opacity, atran, blue, cdist, cloud_qa, coastal, drad, emis, emsd, green, lwir, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs you can see, the results from this query are exactly equivalent to those from stac_search(). For straightforward queries like this, stac_search() provides an easier and friendlier interface for constructing requests. However, using CQL2 via ext_filter() allows us to take full advantage of the metadata provided by the STAC API.\nFor instance, we could also filter our results to only include data from Landsat-8, using the platform property that we examined earlier. To do so, we’ll add another filter using == to our query:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}}) && \n      platform == \"landsat-8\"\n  ) |&gt;\n  rstac::post_request()\n\n###STACItemCollection\n- features (6 item(s)):\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n- assets: \nang, atran, blue, cdist, coastal, drad, emis, emsd, green, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nWe could also use other logical operators to filter these results down further. For instance, the eo:cloud_cover property, part of the electro-optical STAC extension, provides an estimate of how much of each image is covered by clouds. We could add a filter to restrict our results to only include images with less than 10% cloud cover using this property and &lt;:\n\nstac_query &lt;- rstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}}) && \n      platform == \"landsat-8\" && \n      `eo:cloud_cover` &lt; 10\n  ) |&gt;\n  rstac::post_request()\n\nrstac is able to translate several other R expressions into CQL2 representations. For a list of supported R expressions and other examples, check out the rstac documentation."
  },
  {
    "objectID": "gdal_cli.html",
    "href": "gdal_cli.html",
    "title": "Download data from a STAC API using GDAL and the command line",
    "section": "",
    "text": "This tutorial walks through how to use the STACIT GDAL Driver to retrieve data from a STAC catalog or collection using GDAL’s command line interface (CLI). We’ll be using data from Planetary Computer’s USGS Land Change Monitoring, Assessment, and Projection (LCMAP) collection as an example.\nWe’re going to assume that you’ve got GDAL installed (version 3.4 or newer), and are working in a Bash-like shell (one that lets you define variables with VAR= and call them with $VAR) with gdalwarp and gdalinfo available. We’ll also use curl, head and jq once to look at the results of an API query – but you can follow the rest of the tutorial without those installed.\nTo download the 2021 LCMAP primary land cover classification (lcpri) for the New York State bounding box, we can use gdalwarp with the STACIT driver like so:\n\ngdalwarp \"STACIT:\\\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\\\":asset=lcpri\" output.tif\n\nCreating output file that is 30000P x 25000L.\nProcessing STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri [1/1] : 0Using internal nodata values (e.g. 0) for image STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri.\nCopying nodata values from source STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri to destination output.tif.\n...10...20...30...40...50...60...70...80...90...100 - done.\n\n\nThat one-liner finds all the lcpri rasters for our spatiotemporal area of interest on Planetary Computer and downloads them, merging them into a single output file as it does so. Depending how familiar you are with HTTP queries, the one-liner probably either makes perfect sense or looks like complete gibberish. The rest of this tutorial will walk through the components of that one-liner, to try and help it make perfect sense to everyone.\nMost of that one-liner is taken up by a single URL, which we use to find out where the relevant rasters we’re after are on the Planetary Computer. The base of that URL points to the Item-Search API endpoint, which is a standardized API endpoint that STAC APIs like Planetary Computer’s provide to let users search through the various collections and items available in the API. Let’s put the URL for that endpoint in a variable called QUERY_URL:\n\nQUERY_URL=\"https://planetarycomputer.microsoft.com/api/stac/v1/search\"\necho $QUERY_URL\n\nhttps://planetarycomputer.microsoft.com/api/stac/v1/search\n\n\nAnother long chunk of the URL in our one-liner is made up by query parameters, which we use to filter down the items provided by the API to just the data products and spatiotemporal range that we want. For instance, we’ll want to set the collections parameter to filter our search to only include LCMAP data:\n\nCOLLECTION=\"usgs-lcmap-conus-v13\"\nQUERY_URL=\"$QUERY_URL?&collections=$COLLECTION\"\necho $QUERY_URL\n\nhttps://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13\n\n\nWe’ll also want to filter our results to only return items that fall within our spatiotemporal area of interest. We can set the temporal range of our query using the datetime parameter, providing a date formatted in RFC 3339 Section 5.6 format. We’ll limit our query to only return data for 2021:\n\nDATETIME=\"2021-01-01/2021-12-31\"\nQUERY_URL=\"$QUERY_URL&datetime=$DATETIME\"\necho $QUERY_URL\n\nhttps://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31\n\n\nWe also need to limit the spatial range of our results, using a bounding box in the WGS 84 coordinate reference system:\n\nWGS84_BBOX=\"-79.762,40.496,-71.856,45.013\"\nQUERY_URL=\"$QUERY_URL&bbox=$WGS84_BBOX\"\necho $QUERY_URL\n\nhttps://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\n\n\nThis is a complete item search query string! If we visited this URL – or accessed it via curl or another utility – we’d see a feature collection listing metadata about all the available LCMAP rasters falling within our area of interest. We could optionally use curl and jq, if they’re installed, to take a peek at what this JSON document looks like:\n\ncurl -s $QUERY_URL | head -n 1 | jq &gt; query.txt\nhead -n 18 query.txt\n\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"id\": \"LCMAP_CU_030007_2021_V13_CCDC\",\n      \"bbox\": [\n        -72.93784998930636,\n        39.594812916149024,\n        -70.76420061777068,\n        41.227407332200016\n      ],\n      \"type\": \"Feature\",\n      \"links\": [\n        {\n          \"rel\": \"collection\",\n          \"type\": \"application/json\",\n          \"href\": \"https://planetarycomputer.microsoft.com/api/stac/v1/collections/usgs-lcmap-conus-v13\"\n        },\n\n\nNow that our query URL is constructed, we need to add a few configuration options to inform GDAL we want to download data from this query using the STACIT driver. We’ll start off by prepending STACIT: in front of our query url, which we’ll also wrap in quotes (using \\\" to make sure those quotes are preserved):\n\nQUERY_URL=\"STACIT:\\\"$QUERY_URL\\\"\"\necho $QUERY_URL\n\nSTACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\"\n\n\nAnd last but not least, we’ll specify that we only want to download the lcpri asset from each of the items returned by our query, by appending :asset=lcpri to the end of this URL:\n\nASSET=\"lcpri\"\nQUERY_URL=\"$QUERY_URL:asset=$ASSET\"\necho $QUERY_URL\n\nSTACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri\n\n\nWe’ve now constructed the URL that we used in the one-liner at the start of this tutorial! Let’s look at what all of those elements look like when combined in a single chunk:\n\nQUERY_URL=\"https://planetarycomputer.microsoft.com/api/stac/v1/search\"\nCOLLECTION=\"usgs-lcmap-conus-v13\"\nDATETIME=\"2021-01-01/2021-12-31\"\nWGS84_BBOX=\"-79.762,40.496,-71.856,45.013\"\nASSET=\"lcpri\"\n\nQUERY_URL=\"$QUERY_URL?&collections=$COLLECTION\"\nQUERY_URL=\"$QUERY_URL&datetime=$DATETIME\"\nQUERY_URL=\"$QUERY_URL&bbox=$WGS84_BBOX\"\nQUERY_URL=\"STACIT:\\\"$QUERY_URL\\\"\"\nQUERY_URL=\"$QUERY_URL:asset=$ASSET\"\necho $QUERY_URL\n\nSTACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri\n\n\nWe’re now able to use this query URL with any GDAL utility, letting us work with this remote data as if it were local. For instance, we can use gdalinfo to get information about the URLs we’d use to download the data we requested, as well as the extent, resolution, and CRS of this dataset:\n\ngdalinfo $QUERY_URL\n\nDriver: VRT/Virtual Raster\nFiles: /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/030007/2021/LCMAP_CU_030007_2021_20220721_V13_CCDC/LCMAP_CU_030007_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/030006/2021/LCMAP_CU_030006_2021_20220721_V13_CCDC/LCMAP_CU_030006_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/030005/2021/LCMAP_CU_030005_2021_20220721_V13_CCDC/LCMAP_CU_030005_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/029007/2021/LCMAP_CU_029007_2021_20220721_V13_CCDC/LCMAP_CU_029007_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/029006/2021/LCMAP_CU_029006_2021_20220721_V13_CCDC/LCMAP_CU_029006_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/029005/2021/LCMAP_CU_029005_2021_20220721_V13_CCDC/LCMAP_CU_029005_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/029004/2021/LCMAP_CU_029004_2021_20220721_V13_CCDC/LCMAP_CU_029004_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/028008/2021/LCMAP_CU_028008_2021_20220721_V13_CCDC/LCMAP_CU_028008_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/028007/2021/LCMAP_CU_028007_2021_20220721_V13_CCDC/LCMAP_CU_028007_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/028006/2021/LCMAP_CU_028006_2021_20220721_V13_CCDC/LCMAP_CU_028006_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/028005/2021/LCMAP_CU_028005_2021_20220721_V13_CCDC/LCMAP_CU_028005_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/028004/2021/LCMAP_CU_028004_2021_20220721_V13_CCDC/LCMAP_CU_028004_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/027008/2021/LCMAP_CU_027008_2021_20220721_V13_CCDC/LCMAP_CU_027008_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/027007/2021/LCMAP_CU_027007_2021_20220721_V13_CCDC/LCMAP_CU_027007_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/027006/2021/LCMAP_CU_027006_2021_20220721_V13_CCDC/LCMAP_CU_027006_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/027005/2021/LCMAP_CU_027005_2021_20220721_V13_CCDC/LCMAP_CU_027005_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/027004/2021/LCMAP_CU_027004_2021_20220721_V13_CCDC/LCMAP_CU_027004_2021_20220628_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/026008/2021/LCMAP_CU_026008_2021_20220721_V13_CCDC/LCMAP_CU_026008_2021_20220629_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/026007/2021/LCMAP_CU_026007_2021_20220721_V13_CCDC/LCMAP_CU_026007_2021_20220629_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/026006/2021/LCMAP_CU_026006_2021_20220721_V13_CCDC/LCMAP_CU_026006_2021_20220629_V13_LCPRI.tif\n       /vsicurl?pc_url_signing=yes&pc_collection=usgs-lcmap-conus-v13&url=https%3A//landcoverdata.blob.core.windows.net/lcmap/CU/V13/025007/2021/LCMAP_CU_025007_2021_20220721_V13_CCDC/LCMAP_CU_025007_2021_20220629_V13_LCPRI.tif\nSize is 30000, 25000\nCoordinate System is:\nPROJCRS[\"AEA        WGS84\",\n    BASEGEOGCRS[\"WGS 84\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Albers Equal Area\",\n            ID[\"EPSG\",9822]],\n        PARAMETER[\"Latitude of false origin\",23,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",-96,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",29.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",45.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"northing\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\nData axis to CRS axis mapping: 1,2\nOrigin = (1184415.000000000000000,2714805.000000000000000)\nPixel Size = (30.000000000000000,-30.000000000000000)\nCorner Coordinates:\nUpper Left  ( 1184415.000, 2714805.000) ( 80d32' 7.55\"W, 46d33'11.84\"N)\nLower Left  ( 1184415.000, 1964805.000) ( 81d58'10.65\"W, 39d54'46.32\"N)\nUpper Right ( 2084415.000, 2714805.000) ( 69d16'10.42\"W, 44d45'58.75\"N)\nLower Right ( 2084415.000, 1964805.000) ( 71d40'23.06\"W, 38d18' 3.23\"N)\nCenter      ( 1634415.000, 2339805.000) ( 75d50'28.69\"W, 42d29'27.07\"N)\nBand 1 Block=128x128 Type=Byte, ColorInterp=Palette\n  NoData Value=0\n\n\nOr we can use gdalwarp to download these assets and merge them into a single file:\n\nOUTPUT_FILE=\"lcpri_nys.tif\"\n\ngdalwarp $QUERY_URL $OUTPUT_FILE\n\nCreating output file that is 30000P x 25000L.\nProcessing STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri [1/1] : 0Using internal nodata values (e.g. 0) for image STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri.\nCopying nodata values from source STACIT:\"https://planetarycomputer.microsoft.com/api/stac/v1/search?&collections=usgs-lcmap-conus-v13&datetime=2021-01-01/2021-12-31&bbox=-79.762,40.496,-71.856,45.013\":asset=lcpri to destination lcpri_nys.tif.\n...10...20...30...40...50...60...70...80...90...100 - done.\n\n\nThe STACIT driver is smart enough to know how to follow the URLs provided by this feature collection to find and download our desired assets, and will even automatically handle authorizing our requests to the Planetary Computer."
  }
]