[
  {
    "objectID": "r_cql.html",
    "href": "r_cql.html",
    "title": "Using rstac and CQL2 to query STAC APIs",
    "section": "",
    "text": "This tutorial builds upon the “Download data from a STAC API using R, rstac, and GDAL” tutorial tutorial, developing more complicated STAC queries using rstac to find, download, and process Landsat data using STAC metadata. That tutorial walks through building queries with rstac, using typical R functions to compose queries and download data. This tutorial walks through using rstac for more complex queries, based on CQL2 and the STAC API Filter Extension, and using the metadata provided by STAC APIs to filter through items and process assets.\nTo run this tutorial, you’ll need the rstac and sf packages. If necessary, you can install both packages via install.packages():\n\ninstall.packages(\"sf\")\ninstall.packages(\"rstac\")\n\nAs in the last tutorial, we’re going to start off by querying Microsoft’s Planetary Computer STAC API to get data for Ashe County, North Carolina. Let’s go ahead and load the geometry for the county:\n\nashe &lt;- sf::read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))[1, ]\n\nsf::st_geometry(ashe) |&gt; plot()\n\n\n\n\nLet’s try and get Landsat imagery for this area from January 2021. As we saw last time, we’re able to find all the STAC Items that match this description using rstac::stac_search(), providing our bounding box, time range, and desired data collection as regular function arguments. To get all the Landsat images for this spatiotemporal area of interest, we might write our query like this:\n\nashe_bbox &lt;- ashe |&gt;\n  sf::st_transform(4326) |&gt;\n  sf::st_bbox()\n\nstac_query &lt;- rstac::stac(\n  \"https://planetarycomputer.microsoft.com/api/stac/v1\"\n) |&gt;\n  rstac::stac_search(\n    collections = \"landsat-c2-l2\",\n    bbox = ashe_bbox,\n    datetime = \"2021-01-01/2021-01-31\"\n  ) |&gt;\n  rstac::get_request()\n\nstac_query\n\n###STACItemCollection\n- features (12 item(s)):\n  - LE07_L2SP_017035_20210127_02_T1\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LE07_L2SP_018035_20210118_02_T1\n  - LE07_L2SP_018034_20210118_02_T2\n  - LE07_L2SP_017035_20210111_02_T2\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n  - LE07_L2SP_018035_20210102_02_T1\n  - LE07_L2SP_018034_20210102_02_T2\n- assets: \nang, atmos_opacity, atran, blue, cdist, cloud_qa, coastal, drad, emis, emsd, green, lwir, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs we can see, this returns 12 separate items. We can also see that those items seem to have different prefixes in their names; some start with LE07, while others start with LC08. We might be able to guess what this means (spoiler alert, LE07 corresponds to Landsat-7 imagery, while LC08 is Landsat-8), but we might also not know which of these items are actually relevant to our search.\nLuckily enough, STAC items include useful metadata about what their associated assets actually represent. This metadata gets converted by rstac into a list, which is then stored in the properties element of each item in our item collection. We can look at the names of these item properties to get a sense of what metadata is available for each of our items:\n\nlapply(stac_query$features, \\(x) names(x$properties)) |&gt; \n  unlist() |&gt; \n  unique()\n\n [1] \"gsd\"                         \"created\"                    \n [3] \"sci:doi\"                     \"datetime\"                   \n [5] \"platform\"                    \"proj:epsg\"                  \n [7] \"proj:shape\"                  \"description\"                \n [9] \"instruments\"                 \"eo:cloud_cover\"             \n[11] \"proj:transform\"              \"view:off_nadir\"             \n[13] \"landsat:wrs_row\"             \"landsat:scene_id\"           \n[15] \"landsat:wrs_path\"            \"landsat:wrs_type\"           \n[17] \"view:sun_azimuth\"            \"landsat:correction\"         \n[19] \"view:sun_elevation\"          \"landsat:cloud_cover_land\"   \n[21] \"landsat:collection_number\"   \"landsat:collection_category\"\n\n\nMany of these fields are defined by the STAC specification as common metadata, which defines fields that should mean the same thing across multiple data providers. For instance, the platform field should detail the “unique name of the specific platform to which the instrument is attached”, which means that we should be able to use it to confirm that the item naming conventions do in fact correspond to whether an image comes from Landsat-7 or Landsat-8:\n\nlapply(\n  stac_query$features, \n  \\(x) data.frame(id = x$id, platform = x$properties$platform)\n) |&gt; \n  do.call(what = rbind)\n\n                                id  platform\n1  LE07_L2SP_017035_20210127_02_T1 landsat-7\n2  LC08_L2SP_018035_20210126_02_T1 landsat-8\n3  LC08_L2SP_018034_20210126_02_T1 landsat-8\n4  LC08_L2SP_017035_20210119_02_T1 landsat-8\n5  LE07_L2SP_018035_20210118_02_T1 landsat-7\n6  LE07_L2SP_018034_20210118_02_T2 landsat-7\n7  LE07_L2SP_017035_20210111_02_T2 landsat-7\n8  LC08_L2SP_018035_20210110_02_T1 landsat-8\n9  LC08_L2SP_018034_20210110_02_T1 landsat-8\n10 LC08_L2SP_017035_20210103_02_T1 landsat-8\n11 LE07_L2SP_018035_20210102_02_T1 landsat-7\n12 LE07_L2SP_018034_20210102_02_T2 landsat-7\n\n\nThis metadata can be really useful to let us decide which items we want to download from, without needing to download the whole data object! To query using these fields, however, we’re going to need to build our queries in a different way. Namely, rather than using rstac::stac_search(), we’re going to have to write our queries in Common Query Language, or CQL2. CQL2 is a draft OGC standard setting out “a generic filter grammar […] used in query operations to identify the subset of resources, such as features, that should be included in a response”. STAC APIs which implement the filter extension can accept CQL2 queries, which can help you filter down the set of items returned by the API.\nCQL2 has a number of component pieces which define logical operators, spatial and temporal filters, and other filtering functiions. We’re going to focus primarily on how to use the most basic components to find items that intersect our spatiotemporal area of interest and have the properties we desire.\nLuckily, rstac supports writing CQL2 queries through the rstac::ext_filter() function, turning R’s logcal operators and objects into valid CQL2 queries. This function helps to translate R expressions into CQL2 that can be sent as a query to a STAC API. A handful of helper functions, prefixed with cql2_, also help translate R objects into valid CQL2 representations.\nFor instance, to turn our stac_search() query into an ext_filter() query, we’ll need to convert both our bounding box and datetime arguments. We can convert our bounding box into a representation that ext_filter() can use via rstac::cql2_bbox_as_geojson():\n\nashe_bbox_geojson &lt;- rstac::cql2_bbox_as_geojson(ashe_bbox)\nashe_bbox_geojson\n\n$type\n[1] \"Polygon\"\n\n$coordinates\n$coordinates[[1]]\n          [,1]     [,2]\n[1,] -81.74091 36.23444\n[2,] -81.23971 36.23444\n[3,] -81.23971 36.58973\n[4,] -81.74091 36.58973\n[5,] -81.74091 36.23444\n\n\nAnd we can convert our datetime into a valid interval using rstac::cql2_interval():\n\ntime_range &lt;- rstac::cql2_interval(\"2021-01-01\", \"2021-01-31\")\ntime_range\n\ninterval(\"2021-01-01\", \"2021-01-31\")\n\n\nWith these objects converted, we’re then able to build a query that uses CQL2 using rstac::ext_filter(). Rather than providing our filters as function arguments, like we did with stac_search(), we’re going to instead provide ext_filter() with a single query expression that combines all of the filters we care about. For instance, to request only items belonging to the Landsat collection, we’ll use == to filter to only items whose collection is landsat-c2-l2:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\"\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2'\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nIn addition to using logical operators, we’ll also use spatial and temporal operators to limit our results to only our area of interest. For instance, we’ll use the t_intersects CQL2 function and our time_range variable to limit our results to just January 2021. We’ll need to wrap our variable in {{}} to tell rstac to replace the variable name with its contents:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}})\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2' AND T_INTERSECTS(datetime,INTERVAL('2021-01-01','2021-01-31'))\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nNotice how we used && to combine these two filters, restricting our results to only items that satisfy both conditions. Also notice how the filter parameter in our rstac query has changed, including a call to T_INTERSECTS()!\nSimilarly, we’ll need to use the s_intersects() CQL2 function to restrict our results to our spatial area of interest using our ashe_bbox_geojson variable:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}})\n  )\n\n###RSTACQuery\n- url: https://planetarycomputer.microsoft.com/api/stac/v1\n- params:\n  - filter: collection = 'landsat-c2-l2' AND T_INTERSECTS(datetime,INTERVAL('2021-01-01','2021-01-31')) AND S_INTERSECTS(geometry,POLYGON((-81.740905671483 36.234442085901,-81.2397076336137 36.234442085901,-81.2397076336137 36.589729047258,-81.740905671483 36.589729047258,-81.740905671483 36.234442085901)))\n- field(s): version, base_url, endpoint, params, verb, encode\n\n\nThis query is equivalent to the one we constructed via stac_search(): we’re filtering our results based on collection and spatiotemporal range. To execute it against Planetary Computer, we’re going to need to use post_request(), rather than get_request(), to send this query as an HTTP POST rather than GET request:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}})\n  ) |&gt;\n  rstac::post_request()\n\n###STACItemCollection\n- features (12 item(s)):\n  - LE07_L2SP_017035_20210127_02_T1\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LE07_L2SP_018035_20210118_02_T1\n  - LE07_L2SP_018034_20210118_02_T2\n  - LE07_L2SP_017035_20210111_02_T2\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n  - LE07_L2SP_018035_20210102_02_T1\n  - LE07_L2SP_018034_20210102_02_T2\n- assets: \nang, atmos_opacity, atran, blue, cdist, cloud_qa, coastal, drad, emis, emsd, green, lwir, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nAs you can see, the results from this query are exactly equivalent to those from stac_search(). For straightforward queries like this, stac_search() provides an easier and friendlier interface for constructing requests. However, using CQL2 via ext_filter() allows us to take full advantage of the metadata provided by the STAC API.\nFor instance, we could also filter our results to only include data from Landsat-8, using the platform property that we examined earlier. To do so, we’ll add another filter using == to our query:\n\nrstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}}) && \n      platform == \"landsat-8\"\n  ) |&gt;\n  rstac::post_request()\n\n###STACItemCollection\n- features (6 item(s)):\n  - LC08_L2SP_018035_20210126_02_T1\n  - LC08_L2SP_018034_20210126_02_T1\n  - LC08_L2SP_017035_20210119_02_T1\n  - LC08_L2SP_018035_20210110_02_T1\n  - LC08_L2SP_018034_20210110_02_T1\n  - LC08_L2SP_017035_20210103_02_T1\n- assets: \nang, atran, blue, cdist, coastal, drad, emis, emsd, green, lwir11, mtl.json, mtl.txt, mtl.xml, nir08, qa, qa_aerosol, qa_pixel, qa_radsat, red, rendered_preview, swir16, swir22, tilejson, trad, urad\n- item's fields: \nassets, bbox, collection, geometry, id, links, properties, stac_extensions, stac_version, type\n\n\nWe could also use other logical operators to filter these results down further. For instance, the eo:cloud_cover property, part of the electro-optical STAC extension, provides an estimate of how much of each image is covered by clouds. We could add a filter to restrict our results to only include images with less than 10% cloud cover using this property and &lt;:\n\nstac_query &lt;- rstac::stac(\"https://planetarycomputer.microsoft.com/api/stac/v1\") |&gt;\n  rstac::ext_filter(\n    collection == \"landsat-c2-l2\" &&\n      t_intersects(datetime, {{time_range}}) &&\n      s_intersects(geometry, {{ashe_bbox_geojson}}) && \n      platform == \"landsat-8\" && \n      `eo:cloud_cover` &lt; 10\n  ) |&gt;\n  rstac::post_request()\n\nrstac is able to translate several other R expressions into CQL2 representations. For a list of supported R expressions and other examples, check out the rstac documentation."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAC Sprint Tutorials",
    "section": "",
    "text": "During STAC Sprint #8 (9/26 - 9/28 2023) I had the opportunity to work on a handful of tutorials geared towards helping non-Python users query and download data from STAC APIs. This website collects the drafts as they existed during that week."
  }
]